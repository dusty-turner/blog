---
title: Parellel Processing and Bootstrapping for Diamonds
author: Dusty Turner
date: '2019-06-05'
slug: parellel-processing-and-bootstrapping-for-diamonds
categories:
  - army math
  - beatnavy
  - datascience
  - foreach
  - bootstrap
tags:
  - army math
  - beatnavy
  - datascience
  - foreach
  - bootstrap
cover: /img/boot.jpg
---



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Often times, I run simulations on my computer to help educate my students about different statistical topics. In doing this, I often end up running fairly “long” simulations that take up more time than what I’d like to use in the classrooms.</p>
<p>Complaining about this let me to Googling, which, as usual, let me to a solution. Posted below is an example of what I learned with an accompanying ShinyApp which helps me explain bootstrapping to my students.</p>
</div>
<div id="gratitude" class="section level2">
<h2>Gratitude</h2>
<p>Much of what I learned I figured out from this nice <a href="https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html">blog post</a> by Matt Jones.</p>
</div>
<div id="problem-to-solve" class="section level2">
<h2>Problem to Solve</h2>
<p>To motivate this problem, I decided I wanted to bootstrap from the <strong>diamonds</strong> data-set to create a range of coefficients which could be the slope and intercept for the linear relationship between the price and cut/carat. Because this could feasibly take a while, I wanted to use parallel processing to split up the bootstrapping portion on several cores.</p>
</div>
<div id="my-old-way" class="section level2">
<h2>My Old Way</h2>
<p>This is how the old me would have done it. I ran a ‘for’ loop to create 100 bootstraped linear regression of a sample from the data.</p>
<pre class="r"><code>data(&quot;diamonds&quot;)

diamonds = diamonds %&gt;%
  select(price,carat,cut)

coefdf = NULL
allsamples = NULL
system.time({
  for (i in 1:100) {
    subsample = diamonds %&gt;%
      sample_frac(.001) %&gt;%
      mutate(iteration = i)
    result = lm(price~cut+carat,data = subsample)
    coef = coefficients(result)
    coefdf = coefdf %&gt;%
      bind_rows(coef)
    allsamples = allsamples %&gt;%
      bind_rows(subsample)
  }
})</code></pre>
<pre><code>##    user  system elapsed 
##    0.22    0.02    0.25</code></pre>
<p>I tracked the time and it doesn’t take all that long… but then again its only 100 loops.</p>
<p>After executing this loop, I can do my future analysis with the following data:</p>
<pre class="r"><code>head(coefdf)</code></pre>
<pre><code>## # A tibble: 6 x 6
##   `(Intercept)` cut.L    cut.Q  cut.C `cut^4` carat
##           &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1        -2219.  519.  -433.   -168.   -185.  7867.
## 2        -3336. 1998. -1142.   1242.    -49.0 8530.
## 3        -2130.  355.   -59.7  -777.   -313.  7589.
## 4        -2991.  855.  -519.     10.6   728.  8962.
## 5        -2932.  468.     3.77  326.     63.5 8725.
## 6        -2331.  976.  -622.    828.    501.  7480.</code></pre>
<pre class="r"><code>head(allsamples)</code></pre>
<pre><code>## # A tibble: 6 x 4
##   price carat cut     iteration
##   &lt;int&gt; &lt;dbl&gt; &lt;ord&gt;       &lt;int&gt;
## 1   684  0.3  Premium         1
## 2 12157  1.59 Ideal           1
## 3  6468  1.25 Ideal           1
## 4   475  0.3  Ideal           1
## 5 13009  1.5  Premium         1
## 6   967  0.34 Ideal           1</code></pre>
<p>But you can see how this can quickly balloon into taking too much time. We can solve that problem with parallel processing.</p>
</div>
<div id="parallel-processing" class="section level2">
<h2>Parallel Processing</h2>
<p>This code requires the following libraries:</p>
<pre class="r"><code>library(tidyverse)
library(foreach)
library(doParallel)</code></pre>
<p>Typically, all of our work is done is series. Sometimes, if jobs can be done in parallel, we can do this by sending them to different cores in our computer. The amount of time that this saves depends on the speed of your computer, the number of cores in which you can put to work doing jobs, and, of course, the amount of work you need done. Also, there is a ‘start up cost’ to firing up a core - but if you have a lot of repetitive processes that can be spread out and little that must be done for each core, you can save a lot of time.</p>
<p>First thing, we determine how many cores we have available on our computer to do the work.</p>
<pre class="r"><code>numCores &lt;- detectCores()
numCores</code></pre>
<pre><code>## [1] 8</code></pre>
<pre class="r"><code>registerDoParallel(numCores)</code></pre>
<p>Now I can execute the same code as above with <code>foreach</code> and <code>%dopar%</code>.</p>
<pre class="r"><code>data(&quot;diamonds&quot;)

diamonds = diamonds %&gt;%
  select(price,carat,cut)

allsamples = NULL
trials &lt;- 10000
system.time({
  r &lt;- foreach(i=icount(trials), .combine=rbind, .packages = &quot;tidyverse&quot;) %dopar% {
    subsample = diamonds %&gt;%
      sample_frac(.01) 
    result = lm(price~cut+carat+0,data = subsample)
    coefs = data.frame(t(coefficients(result)))
    list(subsample,coefs)
  }
})</code></pre>
<pre><code>##    user  system elapsed 
##    5.40    0.86   16.26</code></pre>
<p>Now we can retrieve the data from our ‘loop’ in the following way:</p>
<pre class="r"><code>coefs = 
bind_rows(r[,2],.id = &quot;iteration&quot;) %&gt;% as_tibble()
head(coefs)</code></pre>
<pre><code>## # A tibble: 6 x 7
##   iteration cutFair cutGood cutVery.Good cutPremium cutIdeal carat
##   &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;        &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;
## 1 result.1   -3430.  -2659.       -2126.     -2195.   -2042. 7733.
## 2 result.2   -4618.  -2788.       -2414.     -2289.   -1939. 7822.
## 3 result.3   -3828.  -2791.       -2326.     -2529.   -2267. 8016.
## 4 result.4   -3312.  -2939.       -2157.     -2107.   -1768. 7506.
## 5 result.5   -4041.  -2780.       -2508.     -2408.   -2139. 8001.
## 6 result.6   -3846.  -3323.       -2323.     -2466.   -2047. 8003.</code></pre>
<pre class="r"><code>sampledata = 
bind_rows(r[,1],.id = &quot;iteration&quot;) %&gt;% as_tibble()
head(sampledata)</code></pre>
<pre><code>## # A tibble: 6 x 4
##   iteration price carat cut  
##   &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;ord&gt;
## 1 result.1   4963  0.83 Ideal
## 2 result.1  12680  2.02 Ideal
## 3 result.1   1192  0.41 Ideal
## 4 result.1   8044  1.06 Ideal
## 5 result.1    956  0.7  Fair 
## 6 result.1    900  0.32 Ideal</code></pre>
<p>Now the point is to find a 95% confidence interval of what the true <span class="math inline">\(\beta_0\)</span> and <span class="math inline">\(\beta_is\)</span> are.</p>
<pre><code>##           vars       25%       95%
## 1      cutFair -4206.658 -3059.029
## 2      cutGood -2939.818 -2323.923
## 3 cutVery.Good -2505.515 -2032.013
## 4   cutPremium -2578.164 -2090.914
## 5     cutIdeal -2183.189 -1809.374
## 6        carat  7726.031  8251.822</code></pre>
<p>Looks like none of the confidence intervals contain <code>0</code>. Therefore carat does have a relationship with price for each level of cut.</p>
</div>
<div id="displaying-the-results" class="section level2">
<h2>Displaying the Results</h2>
<p>The ShinyApp I use to display the results is below.</p>
<p>If you’d rather view the app outside the blog, here is the <a href="https://westpointmath.shinyapps.io/parallelbootstrapdiamonds/">link</a></p>
<center>
<iframe src="https://westpointmath.shinyapps.io/parallelbootstrapdiamonds/" width="1000" height="500&quot;">
</iframe>
</center>
<p>I also include the code for the ShinyApp below the embedded application.</p>
<pre class="r"><code>allsamples = NULL
trials &lt;- 10000
  r &lt;-
    foreach(i = icount(trials),.combine = rbind,.packages = &quot;tidyverse&quot;) %dopar% {
              subsample = diamonds %&gt;%
                sample_frac(.001)
              result = lm(price ~ cut + carat + 0, data = subsample)
              coefs = data.frame(t(coefficients(result)))
              list(subsample, coefs)
            }

sampledata =
  bind_rows(r[, 1], .id = &quot;iteration&quot;)
coefs =
  bind_rows(r[, 2], .id = &quot;iteration&quot;)

help =
  sampledata %&gt;% as_tibble() %&gt;% janitor::clean_names()

coefdata =
  coefs %&gt;% as_tibble() %&gt;%
  gather(cuttype, intercept, -carat, -iteration)

shinyApp(
  ui = fluidPage(
    sliderInput(
      &quot;number&quot;,
      &quot;Which Iteration to Display&quot;,
      min = 1,
      max = trials,
      value = floor(runif(1, 1, trials))
    ),
    plotOutput(&quot;diamond&quot;)
  ),
  
  server = function(input, output) {
    subhelp = reactive({
      help %&gt;%
        mutate(iteration = as.numeric(str_remove(iteration, &quot;result.&quot;))) %&gt;%
        filter(iteration == input$number)
    })
    
    subcoefdata = reactive({
      coefdata %&gt;%
        mutate(iteration = as.numeric(str_remove(iteration, &quot;result.&quot;))) %&gt;%
        filter(iteration == input$number)
    })
    
    output$diamond = renderPlot({
      diamonds %&gt;%
        ggplot(aes(x = carat, y = price)) +
        geom_point(alpha = .1) +
        geom_point(data = subhelp(),
                   aes(x = carat, y = price),
                   color = &quot;blue&quot;) +
        geom_abline(data = subcoefdata(),
                    aes(intercept = intercept, slope = carat),
                    color = &quot;red&quot;) +
        facet_wrap( ~ cuttype, drop = TRUE, nrow = 1) +
        labs(
          x = &quot;Carat&quot;,
          y = &quot;Price&quot;,
          title = &quot;Price of Diamond as Carat Increases&quot;,
          subtitle = &quot;By Cut&quot;,
          caption = paste(&quot;Currently Showing Bootstrap Sample &quot;, input$number)
        )
    })
  },
  
  options = list(height = 1000)
)</code></pre>
</div>
